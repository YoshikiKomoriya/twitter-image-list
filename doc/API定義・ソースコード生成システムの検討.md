# API 定義・ソースコード生成システムの検討

## 結論

- 採用したのは[Open API](https://swagger.io/resources/open-api/) + [open-api-generator](https://openapi-generator.tech/) + [express-openapi-validator](https://github.com/cdimascio/express-openapi-validator)
  - gRCP はプロキシを間に挟むのがネック
    - 個人開発でリソースが限られているため、なるべくシンプルな設計にしてサクッと管理したい
  - GraphQL はオーバースペック気味
    - API の要件的には、Twitter の API を叩いてそのまま返却するだけで十分
      - 出力データが多いため通信量が増えるが、テキストデータなのでそこまで大きな影響はない…と信じる
      - 出力データが多い分、クライアントの処理にマシンパワーが必要になるが、最近の端末は高スペック化しているので大丈夫だと思う…

## 要件

### 必須

- サーバー/フロント共通で扱える型定義ファイルが欲しい
  - TypeScript を使っているので、特徴である補完機能を活かしたい

### オプション

- ドキュメントの生成もできると、仕様を思い出しやすい
- ソースコードの自動生成があると嬉しい
  - 書式等に制約ができるため、もし不便さが大きい場合は、生成したコードは使わない
  - API 通信部だけではなく、バリデーションのコードも生成できるとベスト

## 前提

### API 設計におけるモデルの違い

#### REST

馴染みのあるやつ
`REST API`と呼ばれたり`RESTful API`と呼ばれたり

https://www.redhat.com/ja/topics/api/what-is-a-rest-api

#### RPC

`Remote Procedure Call`の略らしい

データ取得に関する関数呼び出しをリモートで実施するイメージ
サーバー/クライアント間で共通の型を実装することにより、リモート経由でも入出力データや処理を容易に想像することができる

[遠隔手続き呼出し - Wikipedia](https://ja.wikipedia.org/wiki/%E9%81%A0%E9%9A%94%E6%89%8B%E7%B6%9A%E3%81%8D%E5%91%BC%E5%87%BA%E3%81%97)

#### GraphQL

一時期 REST の痒いところに手が届くと話題になったやつ
取得する情報をクエリで定義できるため、クライアントの自由度が高くなる
反対に、バックエンドの実装は工数や工夫が必要となる

https://graphql.org/

## 検討

### Open API

https://swagger.io/resources/open-api/

- RESTful な API を前提とした設計思想

  - Google は[REST API ではないと突っ込んでいる](https://cloud.google.com/blog/ja/products/api-management/understanding-grpc-openapi-and-rest-and-when-to-use-them)が…

- データフォーマットは`YAML` or `JSON`
  - 相互に変換できるらしいので、形式にそこまでこだわらなくていいかも
- データの定義が書きづらい…
  - OpenAPI の書式が少し冗長だと思う
    - このぐらい詳細的でないと型として不十分なのかもしれない
- データフォーマットの選択
  - `YAML` を選択
    - 個人的に設定ファイルといえば YAML のイメージがあるため、そこと合致する
    - どちらも「すごく最適」といったレベルのエディターがなさそう…？
      - JSON のメリットが減るため、消去法で YAML を選択
  - `YAML` : 書式がシンプルなため、スッキリした見た目
  - `JSON` : エディターが豊富で扱いやすい
    - コードの総量の少なさでは YAML に軍配が上がると思う
      - タグを閉じるための括弧によって、無駄な行が多く発生する

#### 関連モジュール

- [open-api-generator](https://openapi-generator.tech/)を使うことで、各ソースコードやドキュメントを出力できる
  - 出力されたコードの品質はマチマチらしいが、TypeScript においては「まあ使えるかな…」程度のコードが出力される印象
- [express-openapi-validator](https://github.com/cdimascio/express-openapi-validator)を使うことで、バリデーション処理を行うことができる
  - 日本語ドキュメントが全くないので、メンテナンスは大変かも

### gRCP

https://grpc.io/docs/platforms/web/
https://knowledge.sakura.ad.jp/24059/

- 基本的に、使いやすいようにブラックボックス化をする設計思想っぽい
  - 生成されたクライアント用コードを使ってリクエストを行う
    - 「エンドポイントを指定してリクエスト」といったことはあまりやらない
- データフォーマットは`Protocol Buffers`（`.proto`）
- HTTP/2 やストリーミング通信を採用しているため、データの速度や通信量でメリットがある
- WEB クライアントで利用する場合、ブラウザの実装状況に合わせて調整を行う必要がある
  - つまり**プロキシを噛ませる必要がある**
    - [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)または[grpc-web](https://github.com/grpc/grpc-web)がよく使われている様子
- [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)を使って、`.proto`から OpenAPI スキーマの出力が可能
  - ただしバージョン 2 の形式である
- データ定義が書きやすい
  - 設定ファイルというよりは、クラス・インターフェイスを書いているような感覚
- 採用するとリッチな構造のシステムになりそう
  - WEB クライアントで扱うにはプロキシを噛ませるため、コストがかかる
- マイクロサービスのデメリットを解消できるため、その方向の需要とは合致すると思う
  - サービスの量に比例して通信量が増えるため、HTTP2 による通信量削減・高速化は相性が良い
  - サービス間の通信で共通の型・ソースが担保されているのは非常に効率的
    - こちらは OpenAPI も同様

### GraphQL

- データ定義が書きやすい
  - Protocol Buffers（gRPC）よりデータ構造を表現する方向に寄っている印象
  - データ構造を表す上だと一番書きやすいと思う
- クエリ機能の恩恵が大きい
  - フロントエンドはユースケース・バックエンドはリソースに関心が向きがちなので、それらを調整する役割に最適
- リゾルバ・ミューテーションの実装が大変
  - 仕組み上仕方ないと納得はできるが…
  - 自動化技術がでているため、そちらを利用すると軽減されるだろう
- 他よりも機能提供の視座が高いレベルにあると思う
  - BFF として採用して、以下のような橋渡しの機能を実装するなんて理想的かも
    - フロントエンド : 自由なクエリ機能
    - バックエンド : 各リソースの取りまとめ
- ある程度の規模からは自動化の技術が必須だと思う
  - 自由度が高い分、各リソースを集計する仕組みが必要である
    - 手動で作り上げるのはあまり現実的でない
  - `GraphQL Mesh` とか面白そう
- 工数が増える傾向にあると思う
  - スペックが高い分、実装にコストがかかる印象がある
